package main

import (
	"bufio"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type savedParam struct {
	Type    string `json:"type"`
	Indexed bool   `json:"indexed"`
	Name    string `json:"name"`
}

type savedEvent struct {
	Selector  string       `json:"selector"`
	Signature string       `json:"signature"`
	Name      string       `json:"name"`
	Inputs    []savedParam `json:"inputs"`
}

func main() {
	var inPath string
	var outPath string
	flag.StringVar(&inPath, "in", "tmp/events_registry.json", "input JSON file produced by event_abi_generator")
	flag.StringVar(&outPath, "out", "pkg/eventdecoder/builtin.go", "output Go file to generate")
	flag.Parse()

	data, err := os.ReadFile(inPath)
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "failed to read input: %v\n", err)
		os.Exit(1)
	}

	var events []savedEvent
	if err := json.Unmarshal(data, &events); err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "failed to parse JSON: %v\n", err)
		os.Exit(1)
	}

	// Deduplicate by selector, first-wins order as in file
	firstWins := make(map[string]savedEvent)
	order := make([]string, 0, len(events))
	for _, ev := range events {
		sel := strings.ToLower(strings.TrimPrefix(ev.Selector, "0x"))
		if len(sel) != 8 { // 4 bytes hex
			continue
		}
		if _, exists := firstWins[sel]; exists {
			continue
		}
		firstWins[sel] = ev
		order = append(order, sel)
	}

	sort.Strings(order)

	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "failed to create output dir: %v\n", err)
		os.Exit(1)
	}

	f, err := os.Create(outPath)
	if err != nil {
		_, _ = fmt.Fprintf(os.Stderr, "failed to create output: %v\n", err)
		os.Exit(1)
	}
	defer func() { _ = f.Close() }()

	// Buffered writer and helpers with error checks
	w := bufio.NewWriter(f)
	defer func() {
		if err := w.Flush(); err != nil {
			_, _ = fmt.Fprintf(os.Stderr, "failed to flush writer: %v\n", err)
			os.Exit(1)
		}
	}()

	mustFprintln := func(a ...any) {
		content := fmt.Sprintln(a...)
		if _, err := w.WriteString(content); err != nil {
			_, _ = fmt.Fprintf(os.Stderr, "failed to write: %v\n", err)
			os.Exit(1)
		}
	}
	mustFprintf := func(format string, a ...any) {
		content := fmt.Sprintf(format, a...)
		if _, err := w.WriteString(content); err != nil {
			_, _ = fmt.Fprintf(os.Stderr, "failed to write: %v\n", err)
			os.Exit(1)
		}
	}

	// File header
	mustFprintln("package eventdecoder")
	mustFprintln()
	mustFprintln("// Code generated by cmd/generate_event_builtins; DO NOT EDIT.")
	mustFprintln()

	// Map literal
	mustFprintln("var builtinSig4 = map[[4]byte]*EventDef{")
	for _, sel := range order {
		ev := firstWins[sel]
		keyLit := fourByteArrayLiteral(sel)
		mustFprintf("    %s: {\n", keyLit)
		mustFprintf("        Name: \"%s\",\n", escape(ev.Name))
		mustFprintf("        Inputs: []ParamDef{\n")
		for _, in := range ev.Inputs {
			mustFprintf("            {Type: \"%s\", Indexed: %t, Name: \"%s\"},\n", escape(in.Type), in.Indexed, escape(in.Name))
		}
		mustFprintln("        },")
		mustFprintln("    },")
	}
	mustFprintln("}")
	mustFprintln()

	// Init merger that preserves existing entries in sig4 (first-wins)
	mustFprintln("func init() {")
	mustFprintln("    mu.Lock()")
	mustFprintln("    for k, v := range builtinSig4 {")
	mustFprintln("        if _, exists := sig4[k]; !exists {")
	mustFprintln("            sig4[k] = v")
	mustFprintln("        }")
	mustFprintln("    }")
	mustFprintln("    mu.Unlock()")
	mustFprintln("}")
}

func fourByteArrayLiteral(sel string) string {
	b, _ := hex.DecodeString(sel)
	return fmt.Sprintf("{0x%02x, 0x%02x, 0x%02x, 0x%02x}", b[0], b[1], b[2], b[3])
}

func escape(s string) string {
	// Minimal escaping for quotes and backslashes
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return s
}
