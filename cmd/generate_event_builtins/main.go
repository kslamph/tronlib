package main

import (
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type savedParam struct {
	Type    string `json:"type"`
	Indexed bool   `json:"indexed"`
	Name    string `json:"name"`
}

type savedEvent struct {
	Selector  string       `json:"selector"`
	Signature string       `json:"signature"`
	Name      string       `json:"name"`
	Inputs    []savedParam `json:"inputs"`
}

func main() {
	var inPath string
	var outPath string
	flag.StringVar(&inPath, "in", "tmp/events_registry.json", "input JSON file produced by event_abi_generator")
	flag.StringVar(&outPath, "out", "pkg/eventdecoder/builtin.go", "output Go file to generate")
	flag.Parse()

	data, err := os.ReadFile(inPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to read input: %v\n", err)
		os.Exit(1)
	}

	var events []savedEvent
	if err := json.Unmarshal(data, &events); err != nil {
		fmt.Fprintf(os.Stderr, "failed to parse JSON: %v\n", err)
		os.Exit(1)
	}

	// Deduplicate by selector, first-wins order as in file
	firstWins := make(map[string]savedEvent)
	order := make([]string, 0, len(events))
	for _, ev := range events {
		sel := strings.ToLower(strings.TrimPrefix(ev.Selector, "0x"))
		if len(sel) != 8 { // 4 bytes hex
			continue
		}
		if _, exists := firstWins[sel]; exists {
			continue
		}
		firstWins[sel] = ev
		order = append(order, sel)
	}

	sort.Strings(order)

	// Ensure output directory exists
	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		fmt.Fprintf(os.Stderr, "failed to create output dir: %v\n", err)
		os.Exit(1)
	}

	f, err := os.Create(outPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to create output: %v\n", err)
		os.Exit(1)
	}
	defer func() { _ = f.Close() }()

	// File header
	fmt.Fprintln(f, "package eventdecoder")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "// Code generated by cmd/generate_event_builtins; DO NOT EDIT.")
	fmt.Fprintln(f)

	// Map literal
	fmt.Fprintln(f, "var builtinSig4 = map[[4]byte]*EventDef{")
	for _, sel := range order {
		ev := firstWins[sel]
		keyLit := fourByteArrayLiteral(sel)
		fmt.Fprintf(f, "    %s: {\n", keyLit)
		fmt.Fprintf(f, "        Name: \"%s\",\n", escape(ev.Name))
		fmt.Fprintf(f, "        Inputs: []ParamDef{\n")
		for _, in := range ev.Inputs {
			fmt.Fprintf(f, "            {Type: \"%s\", Indexed: %t, Name: \"%s\"},\n", escape(in.Type), in.Indexed, escape(in.Name))
		}
		fmt.Fprintln(f, "        },")
		fmt.Fprintln(f, "    },")
	}
	fmt.Fprintln(f, "}")
	fmt.Fprintln(f)

	// Init merger that preserves existing entries in sig4 (first-wins)
	fmt.Fprintln(f, "func init() {")
	fmt.Fprintln(f, "    mu.Lock()")
	fmt.Fprintln(f, "    for k, v := range builtinSig4 {")
	fmt.Fprintln(f, "        if _, exists := sig4[k]; !exists {")
	fmt.Fprintln(f, "            sig4[k] = v")
	fmt.Fprintln(f, "        }")
	fmt.Fprintln(f, "    }")
	fmt.Fprintln(f, "    mu.Unlock()")
	fmt.Fprintln(f, "}")
}

func fourByteArrayLiteral(sel string) string {
	b, _ := hex.DecodeString(sel)
	return fmt.Sprintf("{0x%02x, 0x%02x, 0x%02x, 0x%02x}", b[0], b[1], b[2], b[3])
}

func escape(s string) string {
	// Minimal escaping for quotes and backslashes
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return s
}
